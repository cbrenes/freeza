//
//  TopEntriesInteractor.swift
//  freeza
//
//  Created by Cesar Brenes on 12/18/20.
//  Copyright (c) 2020 Zerously. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

class TopEntriesInteractor: MainEntryBusinessLogic, MainEntryDataStore {
    
    var presenter: MainEntryPresentationLogic?
    var apiWorker: APIWorker
    var afterTag: String?
    var apiEntries = [EntryModel]()
    var favorites = [String]() {
        didSet{
            updateDataSource()
        }
    }
    var entryDBWorker: EntryWorker?
    var indexPathToUpdate: IndexPath?
    var userDefaultObserver: NSKeyValueObservation?
    var safeMode: Bool = LocalQuickStorageWorker(store: UserDefaultsService()).get(key: User.Defaults.safe.rawValue) as? Bool ?? false {
        didSet {
            updateDataSource()
        }
    }
    
    init() {
        apiWorker = APIWorker(store: RedditMockAPI())
        userDefaultObserver = UserDefaults.standard.observe(\.safe, options: [.initial, .new], changeHandler: {[weak self] (defaults, change) in
            if let newValue = change.newValue {
                self?.safeMode = newValue
            }
        })
    }
    
    deinit {
        userDefaultObserver?.invalidate()
    }
    
    func requestDataStore(request: MainEntry.DataStore.Request) {
        DispatchQueue.global(qos: .userInitiated).async {
            self.apiWorker.fetchTop(after: self.afterTag) { [weak self] (entriesList, afterTag) in
                self?.afterTag = afterTag
                self?.apiEntries += entriesList
                self?.validateInformationWithDB(errorMessage: nil)
            } errorHandler: { [weak self] (message) in
                self?.validateInformationWithDB(errorMessage: message)
            }
        }
    }
    
    func requestDetail(request: MainEntry.Detail.Request) {
        presenter?.presentDetail(response: MainEntry.Detail.Response(item: apiEntries[request.indexPath.row], indexPath: request.indexPath, safePreference: safeMode))
    }
    
    func requestFavorite(request: MainEntry.Favorite.Request) {
        indexPathToUpdate = request.indexPath
        var entry = apiEntries[request.indexPath.row]
        if !favorites.contains(entry.id ?? "") {
            entryDBWorker?.insert(entryModel: entry) { [weak self] in
                entry.isFavorite = true
                self?.apiEntries[request.indexPath.row] = entry
            } errorHandler: { (_) in
                //pending to handle DB issues
            }
        } else {
            entryDBWorker?.delete(id: entry.id ?? "") { [weak self] in
                entry.isFavorite = false
                self?.apiEntries[request.indexPath.row] = entry
            } errorHandler: { (_) in
                //pending to handle DB issues
            }
        }
    }
}

extension TopEntriesInteractor {
    func updateDataSource() {
        if let indexPathToUpdate = indexPathToUpdate {
            presenter?.presentFavorite(response: MainEntry.Favorite.Response(indexPath: indexPathToUpdate, item: apiEntries[indexPathToUpdate.row], safePreference: safeMode))
            self.indexPathToUpdate = nil
        } else {
            presentDataSource(errorMessage: nil)
        }
    }
    
    func presentDataSource(errorMessage: String?) {
        let items = updateFavoritePropertyInApiList(apiEntries: apiEntries, favoritesId: favorites)
        presenter?.presentDataSource(response: MainEntry.DataStore.Response(items: items, errorMessage: errorMessage, safePreference: safeMode))
        indexPathToUpdate = nil
    }
    
    func updateFavoritePropertyInApiList(apiEntries: [EntryModel], favoritesId: [String]) -> [EntryModel] {
        return apiEntries.map({EntryModel(title: $0.title, author: $0.author, creation: $0.creation, thumbnailURL: $0.thumbnailURL, commentsCount: $0.commentsCount, url: $0.url, id: $0.id, isOver18: $0.isOver18, isFavorite: favoritesId.contains($0.id ?? ""))})
    }
    
    func startListeningDBChanges() {
        entryDBWorker?.fetchAll(withObserver: true) {[weak self] (favoritesEnties) in
            self?.favorites = favoritesEnties.map({$0.id ?? ""})
        } errorHandler: { (errorMessage) in
            //pending to handle DB issues like the device is out of memory
        }
    }
    
    func validateInformationWithDB(errorMessage: String?) {
        if entryDBWorker == nil {
            DispatchQueueHelper.executeInMainThread {
                self.entryDBWorker = EntryWorker(store: EntryRealmStore())
                self.startListeningDBChanges()
            }
        } else {
            presentDataSource(errorMessage: errorMessage)
        }
    }
}
